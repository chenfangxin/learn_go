# 函数(function)和方法(method)

## 函数的定义

函数的定义格式如下：
```
func FUNC_NAME (<arg_list>) <return_list> {
	<statement>
}
```

函数的定义格式中，左大括号必须与`func`在同一行；参数列表放在小括号里，没有参数时，`arg_list`可以为空；返回值类型列表也放在小括号，没有或只有一个返回值时，可以不用小括号；没有返沪值时，返回值类型列表可以省略。

> go语言支持命名返回值，其实就相当于隐式定义了一个变量，给该变量赋值就是在设置函数的返回值。定义了命名返回值的函数中，return关键字后不用再带返回值。

## 方法的定义
方法是与指定类型关联的**函数**，可以理解为类的成员函数。其定义格式如下：

```
func (p MYTYPE)FUNC_NAME (<arg_list>) <return_list> {
	<statement>
}
```

方法的定义格式中，`(p MYTYPE)`称为接收者(receiver)。`MYTYPE`是与函数关联的类型，`p`称为接收者变量，在函数体中使用该变量。

go语言，**不支持**函数的命名嵌套(nested)定义，重载(overload)和默认参数(default parameter)

go语言中，函数是**第一类值**，允许将函数作为参数和返回值！

> 可以先用`type`定义自己的函数类型，然后用在函数作为参数或返回值的场景，提高代码可读性！

go程序以`main`函数作为起点。

## 参数和返回值
go语言中，参数采用**传值**的方式传递给函数体。go语言支持不定长度参数(其本质是一个slice)。

go语言支持多返回值。**注意：** 在go语言中，允许返回一个函数体内的局部变量的地址！

## 块与作用域

在go语言中，每一对{}包围的语句，称为一个`块`。除了显式的代码块，go语言中还有`隐式块`：

+ 包含所有go源文件中的标识符的**全域块**
+ 包含package内所有源文件中标识符的**包块**
+ 包含本文件内所有标识符的**文件块**
+ `if`,`for`,`switch`,`select`及其子句所代表的**语法块**

在go中，**标识符**必须由字母或数字组成，且第一个字符必须是字母。

在go中，作用域的规定如下：
+ 预定义的标识符的作用域为全局块
+ 定义在任何函数体之外的标识符，作用域为包块
+ 定义在函数体内的标识符，其作用域起于标识符的实现处，能达到最内部语法块


## defer语句
在go语言中，defer语句用于指定延迟执行函数。需要注意的是：

+ 一个函数内部，可以定义多个`defer`语句，其执行顺序是按`defer`语句执行的**逆序**进行。
+ 传给延迟执行的函数的参数，是在`defer`语句执行时求值的

```
func f_A(a int){
	fmt.Printf("a=%d\n", a)
}

func A(){
	for i:=0; i<5; i++ {
		defer f_A(i) // 定义多个defer，并传入参数
	}
}
```
## 匿名函数

在go语言中，函数体中**只允许**嵌套定义匿名函数。示例如下：
```
func main(){
	var a = 10
	func (i int){
		fmt.Printf("i=%d\n", i)
	}(a)  // 定义一个匿名函数，并调用之
}

```
## 闭包
