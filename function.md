# 函数(function)和方法(method)

## 函数的定义

函数的定义格式如下：
```
func FUNC_NAME (<arg_list>) <return_list> {
	<statement>
}
```

函数的定义格式中，左大括号必须与`func`在同一行；参数列表放在小括号里，没有参数时，`arg_list`可以为空；返回值类型列表也放在小括号，没有或只有一个返回值时，可以不用小括号；没有返沪值时，返回值类型列表可以省略。

> go语言支持命名返回值，其实就相当于隐式定义了一个变量，给该变量赋值就是在设置函数的返回值。定义了命名返回值的函数中，return关键字后不用再带返回值。

## 方法的定义
方法是与指定类型关联的**函数**，可以理解为类的成员函数。其定义格式如下：

```
func (p MYTYPE)FUNC_NAME (<arg_list>) <return_list> {
	<statement>
}
```

方法的定义格式中，`(p MYTYPE)`称为接收者(receiver)。`MYTYPE`是与函数关联的类型，`p`称为接收者变量，可以在函数体中使用该变量(相当于C++中的this指针)。go语言的这种给类型添加方法的方式，成为**非侵入式**。

go语言，**不支持**函数的命名嵌套(nested)定义，重载(overload)和默认参数(default parameter)

go语言中，函数是**第一类值**，允许将函数作为参数和返回值！

> 可以先用`type`定义自己的函数类型，然后用在函数作为参数或返回值的场景，提高代码可读性！

go程序以`main`函数作为起点。

#### T型方法和`*T`型方法


## 参数和返回值

go语言中，参数采用**传值**的方式传递给函数体。go语言支持不定长度参数(其本质是一个slice)。

go语言支持多返回值。**注意：** 在go语言中，返回一个函数体内的局部变量的地址是安全的！

## 块与作用域

在go语言中，每一对{}包围的语句，称为一个`块`。除了显式的代码块，go语言中还有`隐式块`：

+ 包含所有go源文件中的标识符的**全域块**
+ 包含package内所有源文件中标识符的**包块**
+ 包含本文件内所有标识符的**文件块**
+ `if`,`for`,`switch`,`select`及其子句所代表的**语法块**

在go中，**标识符**必须由字母或数字组成，且第一个字符必须是字母。

在go中，作用域的规定如下：
+ 预定义的标识符的作用域为全局块
+ 定义在任何函数体之外的标识符，作用域为包块
+ 定义在函数体内的标识符，其作用域起于标识符的实现处，能达到最内部语法块

由此可见，函数体内部可用的变量来源：
1. 函数的参数
2. 函数体内部定义的局部变量
3. 函数的命名返回值
4. 函数所绑定的receiver
5. 函数嵌套定义时，上级语法块中的可用变量
6. 包块和全局块中的变量

## defer语句
在go语言中，defer语句用于指定**延迟调用**的函数。需要注意的是：

+ 一个函数内部，可以定义多个`defer`语句，其执行顺序是按`defer`语句执行的**逆序**进行。
+ 传给延迟执行的函数的参数，是在`defer`语句执行时求值的

```
func f_A(a int){
	fmt.Printf("a=%d\n", a)
}

func A(){
	for i:=0; i<5; i++ {
		defer f_A(i) // 定义多个defer，并传入参数
	}
	
	for i; i<5; i++ {
		defer func(){ // 定义匿名函数，并在defer语句中注册，注意i的值
			fmt.Printf("in func: i=%d\n", i)
		}()
	}
}
```
> 延迟调用的本质，还是函数调用

## 匿名函数

在go语言中，函数体中**只允许**嵌套定义匿名函数。示例如下：
```
func main(){
	var a = 10
	func (i int){
		fmt.Printf("i=%d\n", i)
	}(a)  // 定义一个匿名函数，并调用之
}

```
## 闭包


## 异常机制

在go语言中，用`panic/recover`模式来处理异常。`panic/recover`是内置函数，其原型如下：
```
func panic(v interface{})
func recover() interface{}
```
有原型可知，`panic`函数能以任何类型变量作为异常状态。`panic`函数会立即中断当前执行流程，并开始执行延迟调用；在延迟调用函数中，可以通过`recover`函数捕获异常，并处理之。


## 接口(interface)

接口(`interface`)是自定义的数据类型，是**方法声明的集和**。其定义格式如下：
```
type Name interface {
	Method1 (arg_list) return_type
	Method2 (arg_list) return_type
	... 
}
```
> 接口定义中可以嵌入其他接口类型，前者称为**超集接口**
> 空接口类型相当于Ptyhon中的object，任何类型的变量都可以被赋值给空接口类型变量

在go中，当一个接收者(`receiver`)实现了某个接口类型的全部方法，那么就将该接收者(`receiver`)视为该接口类型的实现，由此可见，这是一种**鸭子类型**。

> 当然一个接收者可以实现多个接口。
